{"response": {"status": "ok", "userTier": "developer", "total": 1, "content": {"id": "technology/blog/2009/jan/01/zune-firmware-mistake", "type": "article", "sectionId": "technology", "sectionName": "Technology", "webPublicationDate": "2009-01-01T18:59:10Z", "webTitle": "Zune bricking code uncovered: it's a leap year mistake, and not Microsoft's", "webUrl": "https://www.theguardian.com/technology/blog/2009/jan/01/zune-firmware-mistake", "apiUrl": "https://content.guardianapis.com/technology/blog/2009/jan/01/zune-firmware-mistake", "fields": {"headline": "Zune bricking code uncovered: it's a leap year mistake, and not Microsoft's", "bodyText": "The flaw that made Zunes freeze has been tracked down, it seems, to a piece of bad programming emanating from Freescale (the semiconductor company spun off from Motorola). Simply put, there was a loop to allow for leap years (as 2008 was). However, it didn't have any way to get past the beginning of the 366th day of the year. Some Zune owners have been poking around in the code for the clock chip, and they explain: The Zune's real-time clock stores the time in terms of days and seconds since January 1st, 1980. When the Zune's clock is accessed, the driver turns the number of days into years/months/days and the number of seconds into hours/minutes/seconds. Likewise, when the clock is set, the driver does the opposite. OK so far. But here's the precise bit of bad programming (apologies, you'll have to do the indents yourself): year = ORIGINYEAR; /* = 1980 */ while (days &gt; 365) { if (IsLeapYear(year)) { if (days &gt; 366) { days -= 366; year += 1; } } else { days -= 365; year += 1; } } Can you see it yet? Yes, it's that (IsLeapYear(year) statement. In 2008, you fall into that loop on the last day: the days &gt; 365, and it's a leap year. On every other day of the year, you have days &lt;= 365.) But there's no way on that particular day for the days to ever exceed 366 during the last day of a leap year. So the poor machine runs around that complete loop forever - or at least until the real-time clock shows that it's now 2009. Rather an elementary mistake, you might think. And it is. But it just goes to show that you should always test for edge conditions. So the fault here isn't Microsoft's; it's Freescale's, or possibly some programmer in a company that provided the firmware for the clock chip. Whatever, if Microsoft doesn't want the same to happen on December 31 2012, it needs a firmware update. True, it's got a little while to figure out what's needed... And of course the fact that last year was a leap year should have clued us to the cause; and also to this not being a Microsoft-derived error. I don't think there's a programmer there who would let such a simple error through. But it also points to incomplete QA testing: did nobody think to ask what happens on February 29th, or December 31st, of 2008?"}, "isHosted": false, "pillarId": "pillar/news", "pillarName": "News"}}}